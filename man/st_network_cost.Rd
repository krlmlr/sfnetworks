% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paths.R
\name{st_network_cost}
\alias{st_network_cost}
\alias{st_network_distance}
\title{Compute a cost matrix of a spatial network}
\usage{
st_network_cost(
  x,
  from = node_ids(x),
  to = node_ids(x),
  weights = edge_length(),
  direction = "out",
  Inf_as_NaN = FALSE,
  ...
)

st_network_distance(
  x,
  from = node_ids(x),
  to = node_ids(x),
  direction = "out",
  Inf_as_NaN = FALSE,
  ...
)
}
\arguments{
\item{x}{An object of class \code{\link{sfnetwork}}.}

\item{from}{The nodes where the paths should start. Can be an integer vector
specifying their indices or a character vector specifying their name. Can
also be an object of class \code{\link[sf]{sf}} or \code{\link[sf]{sfc}}
containing spatial features. In that case, these feature will be snapped to
their nearest node before finding the paths. By default, all nodes in the
network are included.}

\item{to}{The nodes where the paths should end. Can be an integer vector
specifying their indices or a character vector specifying their name. Can
also be an object of class \code{\link[sf]{sf}} or \code{\link[sf]{sfc}}
containing spatial features. In that case, these feature will be snapped to
their nearest node before finding the paths. By default, all nodes in the
network are included.}

\item{weights}{The edge weights to be used in the shortest path calculation.
Can be a numeric vector of the same length as the number of edges, a
\link[=spatial_edge_measures]{spatial edge measure function}, or a column in
the edges table of the network. Tidy evaluation is used such that column
names can be specified as if they were variables in the environment (e.g.
simply \code{length} instead of \code{igraph::edge_attr(x, "length")}).
If set to \code{NULL} or \code{NA} no edge weights are used, and the
shortest path is the path with the fewest number of edges, ignoring space.
The default is \code{\link{edge_length}}, which computes the geographic
lengths of the edges.}

\item{direction}{The direction of travel. Defaults to \code{'out'}, meaning
that the direction given by the network is followed and costs are computed
from the points given as argument \code{from}. May be set to \code{'in'},
meaning that the opposite direction is followed an costs are computed
towards the points given as argument \code{from}. May also be set to
\code{'all'}, meaning that the network is considered to be undirected. This
argument is ignored for undirected networks.}

\item{Inf_as_NaN}{Should the cost values of unconnected nodes be stored as
\code{NaN} instead of \code{Inf}? Defaults to \code{FALSE}.}

\item{...}{Additional arguments passed on to \code{\link[igraph]{distances}}.
Instead of the \code{mode} argument, use the \code{direction} argument.}
}
\value{
An n times m numeric matrix where n is the length of the \code{from}
argument, and m is the length of the \code{to} argument.
}
\description{
Compute total travel costs of shortest paths between nodes in a spatial
network.
}
\details{
\code{st_network_cost} allows to use any set of edge weights, while
\code{st_network_distance} is a intuitive synonym for cost matrix computation
in which the edge weights are set to their geographic length.

Spatial features provided to the \code{from} and/or \code{to} argument don't
necessarily have to be points. Internally, the nearest node to each feature
is found by calling \code{\link[sf]{st_nearest_feature}}, so any feature
with a geometry type that is accepted by that function can be provided as
\code{from} and/or \code{to} argument.

When directly providing integer node indices or character node names to the
\code{from} and/or \code{to} argument, keep the following in mind. A node
index should correspond to a row-number of the nodes table of the network.
A node name should correspond to a value of a column in the nodes table
named \code{name}. This column should contain character values without
duplicates.

For more details on the wrapped igraph function see the
\code{\link[igraph]{distances}} documentation page.
}
\examples{
library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

net = as_sfnetwork(roxel, directed = FALSE) |>
  st_transform(3035)

# Compute the network cost matrix between node pairs.
# Note that geographic edge length is used as edge weights by default.
st_network_cost(net, from = c(495, 121), to = c(495, 121))

# st_network_distance is a synonym for st_network_cost with default weights.
st_network_distance(net, from = c(495, 121), to = c(495, 121))

# Compute the network cost matrix between spatial point features.
# These are snapped to their nearest node before computing costs.
p1 = st_geometry(net, "nodes")[495] + st_sfc(st_point(c(50, -50)))
st_crs(p1) = st_crs(net)
p2 = st_geometry(net, "nodes")[121] + st_sfc(st_point(c(-10, 100)))
st_crs(p2) = st_crs(net)

st_network_cost(net, from = c(p1, p2), to = c(p1, p2))

# Use a spatial edge measure to specify edge weights.
# By default edge_length() is used.
st_network_cost(net, c(p1, p2), c(p1, p2), weights = edge_displacement())

# Use a column in the edges table to specify edge weights.
# This uses tidy evaluation.
net |>
  activate("edges") |>
  mutate(foo = runif(n(), min = 0, max = 1)) |>
  st_network_cost(c(p1, p2), c(p1, p2), weights = foo)

# Compute the cost matrix without edge weights.
# Here the cost is defined by the number of edges, ignoring space.
st_network_cost(net, c(p1, p2), c(p1, p2), weights = NULL)

# Not providing any from or to points includes all nodes by default.
with_graph(net, graph_order()) # Our network has 701 nodes.
cost_matrix = st_network_cost(net)
dim(cost_matrix)

}
\seealso{
\code{\link{st_network_paths}}
}
