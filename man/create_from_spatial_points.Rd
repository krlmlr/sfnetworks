% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create.R
\name{create_from_spatial_points}
\alias{create_from_spatial_points}
\title{Create a spatial network from point geometries}
\usage{
create_from_spatial_points(
  x,
  connections = "complete",
  directed = TRUE,
  edges_as_lines = TRUE,
  compute_length = FALSE,
  k = 1
)
}
\arguments{
\item{x}{An object of class \code{\link[sf]{sf}} or \code{\link[sf]{sfc}}
with \code{POINT} geometries.}

\item{connections}{How to connect the given point geometries to each other?
Can be specified either as an adjacency matrix, or as a character
describing a specific method to define the connections.}

\item{directed}{Should the constructed network be directed? Defaults to
\code{TRUE}.}

\item{edges_as_lines}{Should the created edges be spatially explicit, i.e.
have \code{LINESTRING} geometries stored in a geometry list column? Defaults
to \code{TRUE}.}

\item{compute_length}{Should the geographic length of the edges be stored in
a column named \code{length}? Uses \code{\link[sf]{st_length}} to compute
the length of the edge geometries when edges are spatially explicit, and
\code{\link[sf]{st_distance}} to compute the distance between boundary nodes
when edges are spatially implicit. If there is already a column named
\code{length}, it will be overwritten. Please note that the values in this
column are \strong{not} automatically recognized as edge weights. This needs
to be specified explicitly when calling a function that uses edge weights.
Defaults to \code{FALSE}.}

\item{k}{The amount of neighbors to connect to if
\code{connections = 'knn'}. Defaults to \code{1}, meaning that nodes are
only connected to their nearest neighbor. Ignored for any other value of the
\code{connected} argument.}
}
\value{
An object of class \code{\link{sfnetwork}}.
}
\description{
Create a spatial network from point geometries
}
\details{
It is assumed that the given points form the nodes in the network.
How those nodes are connected by edges depends on the \code{connections}
argument.

The connections can be specified through an adjacency matrix A, which is an
n x n matrix with n being the number of nodes, and element Aij holding a
\code{TRUE} value if there is an edge from node i to node j, and a
\code{FALSE} value otherwise. In the case of undirected networks, the matrix
is not tested for symmetry, and an edge will exist between node i and node j
if either element Aij or element Aji is \code{TRUE}. Non-logical matrices
are first converted into logical matrices using \code{\link{as.logical}}.

The provided adjacency matrix may also be a list-formatted sparse matrix.
This is a list with one element per node, holding the integer indices of the
nodes it is adjacent to. An example are \code{\link[sf]{sgbp}} objects.

Alternatively, the connections can be specified by providing the name of a
specific method that will create the adjacency matrix internally. Valid
options are:

\itemize{
  \item \code{complete}: All nodes are directly connected to each other.
  \item \code{sequence}: The nodes are sequentially connected to each other,
  meaning that the first node is connected to the second node, the second
  node is connected to the third node, et cetera.
  \item \code{mst}: The nodes are connected by their spatial
  \href{https://en.wikipedia.org/wiki/Minimum_spanning_tree}{minimum
  spanning tree}, i.e. the set of edges with the minimum total edge length
  required to connect all nodes. The tree is always constructed on an
  undirected network, regardless of the value of the \code{directed}.
  argument. If \code{directed = TRUE}, each edge is duplicated and reversed
  to ensure full connectivity of the network. Can also be specified as
  \code{minimum_spanning_tree}.
  \item \code{delaunay}: The nodes are connected by their
  \href{https://en.wikipedia.org/wiki/Delaunay_triangulation}{Delaunay
  triangulation}.
  Requires the \href{https://r-spatial.github.io/spdep/index.html}{spdep}
  package to be installed, and assumes planar coordinates.
  \item \code{gabriel}: The nodes are connected as a
  \href{https://en.wikipedia.org/wiki/Gabriel_graph}{Gabriel graph}.
  Requires the \href{https://r-spatial.github.io/spdep/index.html}{spdep}
  package to be installed, and assumes planar coordinates.
  \item \code{rn}: The nodes are connected as a
  \href{https://en.wikipedia.org/wiki/Relative_neighborhood_graph}{relative
  neighborhood graph}. Can also be specified as \code{relative_neighborhood}
  or \code{relative_neighbourhood}.
  Requires the \href{https://r-spatial.github.io/spdep/index.html}{spdep}
  package to be installed, and assumes planar coordinates.
  \item \code{knn}: Each node is connected to its k nearest neighbors, with
  \code{k} being specified through the \code{k} argument. By default,
  \code{k = 1}, meaning that the nodes are connected as a
  \href{https://en.wikipedia.org/wiki/Nearest_neighbor_graph}{nearest
  neighbor graph}. Can also be specified as \code{nearest_neighbors} or
  \code{nearest_neighbours}.
  Requires the \href{https://r-spatial.github.io/spdep/index.html}{spdep}
  package to be installed.
}
}
\examples{
library(sf, quietly = TRUE)

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))

pts = roxel[seq(1, 100, by = 10),] |>
  st_geometry() |>
  st_centroid() |>
  st_transform(3035)

# Using an adjacency matrix
adj = matrix(c(rep(TRUE, 10), rep(FALSE, 90)), nrow = 10)
net = as_sfnetwork(pts, connections = adj)

plot(net)

# Using a sparse adjacency matrix from a spatial predicate
dst = units::set_units(500, "m")
adj = st_is_within_distance(pts, dist = dst)
net = as_sfnetwork(pts, connections = adj)

plot(net)

# Using pre-defined methods
cnet = as_sfnetwork(pts, connections = "complete")
snet = as_sfnetwork(pts, connections = "sequence")
mnet = as_sfnetwork(pts, connections = "mst")
dnet = as_sfnetwork(pts, connections = "delaunay")
gnet = as_sfnetwork(pts, connections = "gabriel")
rnet = as_sfnetwork(pts, connections = "rn")
nnet = as_sfnetwork(pts, connections = "knn")
knet = as_sfnetwork(pts, connections = "knn", k = 2)

par(mar = c(1,1,1,1), mfrow = c(4,2))

plot(cnet, main = "complete")
plot(snet, main = "sequence")
plot(mnet, main = "minimum spanning tree")
plot(dnet, main = "delaunay triangulation")
plot(gnet, main = "gabriel graph")
plot(rnet, main = "relative neighborhood graph")
plot(nnet, main = "nearest neighbor graph")
plot(knet, main = "k nearest neighbor graph (k = 2)")

par(oldpar)

}
