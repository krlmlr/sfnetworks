% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paths.R
\name{st_network_paths}
\alias{st_network_paths}
\title{Find paths between nodes in a spatial network}
\usage{
st_network_paths(
  x,
  from,
  to = node_ids(x),
  weights = edge_length(),
  type = "shortest",
  direction = "out",
  use_names = TRUE,
  ...
)
}
\arguments{
\item{x}{An object of class \code{\link{sfnetwork}}.}

\item{from}{The node where the paths should start. Can be an integer
specifying its index or a character specifying its name. Can also be an
object of class \code{\link[sf]{sf}} or \code{\link[sf]{sfc}} containing a
single spatial feature. In that case, this feature will be snapped to its
nearest node before finding the paths. When multiple indices, names or
features are given, only the first one is used.}

\item{to}{The nodes where the paths should end. Can be an integer vector
specifying their indices or a character vector specifying their name. Can
also be an object of class \code{\link[sf]{sf}} or \code{\link[sf]{sfc}}
containing spatial features. In that case, these feature will be snapped to
their nearest node before finding the paths. By default, all nodes in the
network are included.}

\item{weights}{The edge weights to be used in the shortest path calculation.
Can be a numeric vector of the same length as the number of edges, a
\link[=spatial_edge_measures]{spatial edge measure function}, or a column in
the edges table of the network. Tidy evaluation is used such that column
names can be specified as if they were variables in the environment (e.g.
simply \code{length} instead of \code{igraph::edge_attr(x, "length")}).
If set to \code{NULL} or \code{NA} no edge weights are used, and the
shortest path is the path with the fewest number of edges, ignoring space.
The default is \code{\link{edge_length}}, which computes the geographic
lengths of the edges.}

\item{type}{Character defining which type of path calculation should be
performed. If set to \code{'shortest'} paths are found using
\code{\link[igraph]{shortest_paths}}, if set to \code{'all_shortest'} paths
are found using \code{\link[igraph]{all_shortest_paths}}, if set to
\code{'all_simple'} paths are found using
\code{\link[igraph]{all_simple_paths}}. Defaults to \code{'shortest'}.}

\item{direction}{The direction of travel. Defaults to \code{'out'}, meaning
that the direction given by the network is followed and paths are found from
the node given as argument \code{from}. May be set to \code{'in'}, meaning
that the opposite direction is followed an paths are found towards the node
given as argument \code{from}. May also be set to \code{'all'}, meaning that
the network is considered to be undirected. This argument is ignored for
undirected networks.}

\item{use_names}{If a column named \code{name} is present in the nodes
table, should these names be used to encode the nodes in a path, instead of
the node indices? Defaults to \code{TRUE}. Ignored when the nodes table does
not have a column named \code{name}.}

\item{...}{Additional arguments passed on to the wrapped igraph functions.
Arguments \code{predecessors} and \code{inbound.edges} are ignored.
Instead of the \code{mode} argument, use the \code{direction} argument.}
}
\value{
An object of class \code{\link[tibble]{tbl_df}} with one row per
returned path. Depending on the setting of the \code{type} argument,
columns can be \code{node_paths} (a list column with for each path the
ordered indices of nodes present in that path) and \code{edge_paths}
(a list column with for each path the ordered indices of edges present in
that path). Type \code{'all_simple'} returns only \code{node_paths}, while
\code{'shortest'} and \code{'all_shortest'} return both.
}
\description{
A function implementing one-to-one and one-to-many routing on spatial
networks. It can be used to either find one shortest path, all shortest
paths, or all simple paths between one node and one or
more other nodes in the network.
}
\details{
Spatial features provided to the \code{from} and/or
\code{to} argument don't necessarily have to be points. Internally, the
nearest node to each feature is found by calling
\code{\link[sf]{st_nearest_feature}}, so any feature with a geometry type
that is accepted by that function can be provided as \code{from} and/or
\code{to} argument.

When directly providing integer node indices or character node names to the
\code{from} and/or \code{to} argument, keep the following in mind. A node
index should correspond to a row-number of the nodes table of the network.
A node name should correspond to a value of a column in the nodes table
named \code{name}. This column should contain character values without
duplicates.

For more details on the wrapped igraph functions see the
\code{\link[igraph]{distances}} and
\code{\link[igraph]{all_simple_paths}} documentation pages.
}
\examples{
library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

net = as_sfnetwork(roxel, directed = FALSE) |>
  st_transform(3035)

# Compute the shortest path between two nodes.
# Note that geographic edge length is used as edge weights by default.
paths = st_network_paths(net, from = 495, to = 121)
paths

node_path = paths |>
  slice(1) |>
  pull(node_paths) |>
  unlist()

node_path

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))

plot(net, col = "grey")
plot(slice(net, node_path), col = "red", add = TRUE)
par(oldpar)

# Compute the shortest paths from one to multiple nodes.
# This will return a tibble with one row per path.
st_network_paths(net, from = 495, to = c(121, 131, 141))

# Compute the shortest path between two spatial point features.
# These are snapped to their nearest node before finding the path.
p1 = st_geometry(net, "nodes")[495] + st_sfc(st_point(c(50, -50)))
st_crs(p1) = st_crs(net)
p2 = st_geometry(net, "nodes")[121] + st_sfc(st_point(c(-10, 100)))
st_crs(p2) = st_crs(net)

paths = st_network_paths(net, from = p1, to = p2)
paths

node_path = paths |>
  slice(1) |>
  pull(node_paths) |>
  unlist()

node_path

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))

plot(net, col = "grey")
plot(c(p1, p2), col = "black", pch = 8, add = TRUE)
plot(slice(net, node_path), col = "red", add = TRUE)
par(oldpar)

# Use a spatial edge measure to specify edge weights.
# By default edge_length() is used.
st_network_paths(net, p1, p2, weights = edge_displacement())

# Use a column in the edges table to specify edge weights.
# This uses tidy evaluation.
net |>
  activate("edges") |>
  mutate(foo = runif(n(), min = 0, max = 1)) |>
  st_network_paths(p1, p2, weights = foo)

# Compute the shortest paths without edge weights.
# This is the path with the fewest number of edges, ignoring space.
st_network_paths(net, p1, p2, weights = NULL)

# Compute all shortest paths between two nodes.
# If there is more than one shortest path, this returns one path per row.
st_network_paths(net, from = 5, to = 1, type = "all_shortest")

}
\seealso{
\code{\link{st_network_cost}}
}
