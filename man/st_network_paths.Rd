% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paths.R
\name{st_network_paths}
\alias{st_network_paths}
\title{Find paths between nodes in a spatial network}
\usage{
st_network_paths(
  x,
  from,
  to = node_ids(x),
  weights = edge_length(),
  type = "shortest",
  direction = "out",
  use_names = TRUE,
  return_cost = TRUE,
  return_geometry = TRUE,
  ...
)
}
\arguments{
\item{x}{An object of class \code{\link{sfnetwork}}.}

\item{from}{The node where the paths should start. Evaluated by
\code{\link{evaluate_node_query}}. When multiple nodes are given, only the
first one is used.}

\item{to}{The node where the paths should start. Evaluated by
\code{\link{evaluate_node_query}}. By default, all nodes in the network are
included.}

\item{weights}{The edge weights to be used in the shortest path calculation.
Evaluated by \code{\link{evaluate_edge_spec}}. The default is
\code{\link{edge_length}}, which computes the geographic lengths of the
edges.}

\item{type}{Character defining which type of path calculation should be
performed. If set to \code{'shortest'} paths are found using
\code{\link[igraph]{shortest_paths}}, if set to \code{'all_shortest'} paths
are found using \code{\link[igraph]{all_shortest_paths}}, if set to
\code{'all_simple'} paths are found using
\code{\link[igraph]{all_simple_paths}}. Defaults to \code{'shortest'}.}

\item{direction}{The direction of travel. Defaults to \code{'out'}, meaning
that the direction given by the network is followed and paths are found from
the node given as argument \code{from}. May be set to \code{'in'}, meaning
that the opposite direction is followed an paths are found towards the node
given as argument \code{from}. May also be set to \code{'all'}, meaning that
the network is considered to be undirected. This argument is ignored for
undirected networks.}

\item{use_names}{If a column named \code{name} is present in the nodes
table, should these names be used to encode the nodes in a path, instead of
the node indices? Defaults to \code{TRUE}. Ignored when the nodes table does
not have a column named \code{name}.}

\item{return_cost}{Should the total cost of each path be computed? Defaults
to \code{TRUE}. Ignored if \code{type = 'all_simple'}.}

\item{return_geometry}{Should a linestring geometry be constructed for each
path? Defaults to \code{TRUE}. The geometries are constructed by calling
\code{\link[sf]{st_line_merge}} on the linestring geometries of the edges in
the path. Ignored if \code{type = 'all_simple'} and for networks with
spatially implicit edges.}

\item{...}{Additional arguments passed on to the wrapped igraph functions.
Arguments \code{predecessors} and \code{inbound.edges} are ignored.
Instead of the \code{mode} argument, use the \code{direction} argument.}
}
\value{
An object of class \code{\link[tibble]{tbl_df}} or
\code{\link[sf]{sf}} with one row per path. If \code{type = 'shortest'}, the
number of rows is always equal to the number of requested paths, meaning
that node pairs for which no path could be found are still part of the
output. For all other path types, the output only contains finite paths.

Depending on the argument setting, the output may include the following
columns:

\itemize{
  \item \code{from}: The index of the node at the start of the path.
  \item \code{to}: The index of the node at the end of the path.
  \item \code{nodes}: A vector containing the indices of all nodes on the
  path, in order of visit.
  \item \code{edges}: A vector containing the indices of all edges on the
  path, in order of visit. Not returned if \code{type = 'all_simple'}.
  \item \code{path_found}: A boolean describing if a path was found between
  the two nodes. Returned only if \code{type = 'shortest'}.
  \item \code{cost}: The total cost of the path, obtained by summing the
  weights of all visited edges. Returned only if \code{return_cost = TRUE}.
  Never returned if \code{type = 'all_simple'}.
  \item \code{geometry}: The geometry of the path, obtained by merging the
  geometries of all visited edges. Returned only if
  \code{return_geometry = TRUE} and the network has spatially explicit
  edges. Never returned if \code{type = 'all_simple'}.
}
}
\description{
A function implementing one-to-one and one-to-many routing on spatial
networks. It can be used to either find one shortest path, all shortest
paths, or all simple paths between one node and one or
more other nodes in the network.
}
\details{
For more details on the wrapped igraph functions see the
\code{\link[igraph]{distances}} and
\code{\link[igraph]{all_simple_paths}} documentation pages.
}
\note{
When computing simple paths by setting \code{type = 'all_simple'},
note that potentially there are exponentially many paths between two nodes,
and you may run out of memory especially in undirected, dense, and/or
lattice-like networks.
}
\examples{
library(sf, quietly = TRUE)
library(tidygraph, quietly = TRUE)

oldpar = par(no.readonly = TRUE)
par(mar = c(1,1,1,1))

net = as_sfnetwork(roxel, directed = FALSE) |>
  st_transform(3035)

# Compute the shortest path between two nodes.
# Note that geographic edge length is used as edge weights by default.
paths = st_network_paths(net, from = 495, to = 121)
paths

plot(net, col = "grey")
plot(st_geometry(paths), col = "red", lwd = 1.5, add = TRUE)

# Compute the shortest paths from one to multiple nodes.
# This will return a tibble with one row per path.
st_network_paths(net, from = 495, to = c(121, 131, 141))

# Compute the shortest path between two spatial point features.
# These are snapped to their nearest node before finding the path.
p1 = st_geometry(net, "nodes")[495] + st_sfc(st_point(c(50, -50)))
st_crs(p1) = st_crs(net)
p2 = st_geometry(net, "nodes")[121] + st_sfc(st_point(c(-10, 100)))
st_crs(p2) = st_crs(net)

paths = st_network_paths(net, from = p1, to = p2)
paths

plot(net, col = "grey")
plot(c(p1, p2), col = "black", pch = 8, add = TRUE)
plot(st_geometry(paths), col = "red", lwd = 1.5, add = TRUE)

# Use a node type query function to specify destinations.
st_network_paths(net, 1, node_is_adjacent(1))

# Use a spatial edge measure to specify edge weights.
# By default edge_length() is used.
st_network_paths(net, p1, p2, weights = edge_displacement())

# Use a column in the edges table to specify edge weights.
# This uses tidy evaluation.
net |>
  activate("edges") |>
  mutate(foo = runif(n(), min = 0, max = 1)) |>
  st_network_paths(p1, p2, weights = foo)

# Compute the shortest paths without edge weights.
# This is the path with the fewest number of edges, ignoring space.
st_network_paths(net, p1, p2, weights = NULL)

par(oldpar)

}
\seealso{
\code{\link{st_network_cost}}, \code{\link{st_network_travel}}
}
