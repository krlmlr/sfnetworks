---
title: "Routing on spatial networks"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{5. Routing on spatial networks}
  %\VignetteEngine{quarto:html}
  %\VignetteEncoding{UTF-8}
format:
  html:
    toc: true
knitr:
  opts_chunk: 
    collapse: true
    comment: '#>'
  opts_knit:
    global.par: true
---

```{r}
#| label: setup
#| include: false
current_geos = numeric_version(sf::sf_extSoftVersion()["GEOS"])
required_geos = numeric_version("3.7.0")
geos37 = current_geos >= required_geos
```

```{r}
#| label: plot
#| echo: false
#| results: asis
# plot margins
oldpar = par(no.readonly = TRUE)
par(mar = c(1, 1, 1, 1))
# crayon needs to be explicitly activated in Rmd
oldoptions = options()
options(crayon.enabled = TRUE)
# Hooks needs to be set to deal with outputs
# thanks to fansi logic
old_hooks = fansi::set_knit_hooks(
  knitr::knit_hooks,
  which = c("output", "message", "error")
)
```

Calculating shortest paths between pairs of nodes is a core task in spatial network analysis. `{sfnetworks}` does not implement its own algorithms to do this, but wraps function from other packages and exposes them through one consistent API that fits within the design of the package. This vignette demonstrates how.

```{r}
#| message: false
library(sfnetworks)
library(sf)
library(tidygraph)
library(ggraph)
library(dplyr)
```

## The basics

In `{sfnetworks}` there are two core functions for routing on spatial networks. The first one, `st_network_paths()`, returns the course of the optimal paths between pairs of nodes. The second one, `st_network_cost()`, returns a matrix of optimal travel costs between pairs of nodes.

Both functions need to be provided with nodes to route from (the origins), and nodes to route to (the destinations). The most basic way of doing this is through the integer node indices, which correspond to the rownumbers of the nodes table. There are many other ways, though, which are explained in detail in [this section](#specifying-origins-and-destinations). Secondly, it should be specified what the weight of each edge is. Higher edge weights result in higher travel costs. By default, `{sfnetworks}` will always use the geographic lengths of the edges. It is possible to specify different edge weights, which is explained in detail in [this section](#specifying-edge-weights).

The function `st_network_paths()` returns a `sf` object with one row per requested path. The column *node_path* contains the indices of the nodes on the path, in order of visit. Similarly, the column *edge_path* contains the indices of the edges on the paths, in order of visit. Column *cost* stores the total travel cost of the path. The geometry column is the linestring that resulted from concatenating the individual geometries of all visited edges.

```{r}
# Create a network.
net = as_sfnetwork(mozart, "gabriel", directed = FALSE)
```

```{r}
# Compute the shortest path between node 1 and nodes 12 and 17.
paths = st_network_paths(net, 1, c(12, 17))
paths
```

```{r}
ggraph(net, "sf") +
  geom_edge_sf(color = "darkgrey") +
  geom_sf(data = paths, color = "orange", linewidth = 2) +
  geom_node_sf(color = "darkgrey", size = 4) +
  geom_sf(data = st_geometry(net, "nodes")[c(1, 12, 17)], size = 6) +
  theme_void()
```

The function `st_network_cost()` returns a $n \times m$ matrix, with $n$ being the number of specified origins, and $m$ being the number of specified destinations. Element $A_{ij}$ stores the total travel cost of the shortest path between the $i$-th origin and the $j$-th destination. This matrix is usually an important starting point for further analysis. For example, it can serve as input to route optimization algorithms, spatial clustering algorithms and the calculation of statistical measures based on spatial proximity.

```{r}
st_network_cost(net, c(1, 12, 17), c(1, 12, 17))
```

There is also the function `st_network_distance()`, which is a synonym for `st_network_cost()` with the edge weights always being the geographic edge length. This function was added to provide an intuitive network-specific alternative to `sf::st_distance()`.

Do note that in our nice little example network all nodes are connected to each other. In many real-world networks this may not always be the case, meaning that some node pairs will not have a path between them. In that case `st_network_paths()` will still return the "path", but with an empty geometry and a `FALSE` value in the *path_found* column. `st_network_cost()` will store an `Inf` value.

```{r}
divided_net = as_sfnetwork(mozart, "knn", k = 3, directed = FALSE)
```

```{r}
#| warning: false
paths = st_network_paths(divided_net, 12, c(1, 17))
paths
```

```{r}
ggraph(divided_net, "sf") +
  geom_edge_sf(color = "darkgrey") +
  geom_sf(data = paths, color = "orange", linewidth = 2) +
  geom_node_sf(color = "darkgrey", size = 4) +
  geom_sf(data = st_geometry(divided_net, "nodes")[c(1, 12, 17)], size = 6) +
  theme_void()
```

```{r}
#| warning: false
st_network_cost(divided_net, c(1, 12, 17), c(1, 12, 17))
```

In many cases, it is a good idea to first extract the largest connected component from your network before computing routes. This can be done by the morpher `tidygraph::to_largest_component()`.

```{r}
# Extract only the largest connected component.
component = convert(divided_net, to_largest_component)
```

```{r}
#| layout-ncol: 2
#| fig-cap: 
#|   - "Full network"
#|   - "Largest component"
ggraph(divided_net, "sf") +
  geom_edge_sf() +
  geom_node_sf(size = 4) +
  theme_void()

ggraph(component, "sf") +
  geom_edge_sf() +
  geom_node_sf(size = 4) +
  theme_void()
```

## Choosing a routing backend

## Specifying origins and destinations

## Specifying edge weights

## Applications

In this section, we will show a small set of applications of the routing related functions. It is not meant to be an overview that covers everything. Also, remember that `{sfnetworks}` is a general-purpose spatial network analysis package not optimized for a specific application. However, especially in combination with other packages it can address a wide variety of use-cases.

### K shortest paths

Thanks to the `{igraph}` routing backend, we can compute not only the shortest path between two nodes, but also the next $k-1$ shortest paths. For this, set the `k` argument of `st_network_paths()` to any integer higher than 1. This is only supported for one-to-one routing, i.e. a single origin and a single destination.

```{r}
paths = st_network_paths(net, 1, 17, k = 5)
paths
```

```{r}
ggraph(net, "sf") +
  geom_edge_sf(color = "darkgrey") +
  geom_sf(data = paths, aes(color = units::drop_units(cost)), linewidth = 2) +
  geom_node_sf(color = "darkgrey", size = 4) +
  geom_sf(data = st_geometry(net, "nodes")[c(1, 17)], size = 6) +
  scale_color_continuous("cost") +
  theme_void()
```

### Closest facility analysis

The purpose of closest facility analysis is, given a set of destination locations (also referred to as the *facilities*) and origin locations (also referred to as the *sites*), to find the closest $n$ facilities to each site. For example, you might want to find the nearest transit hub for each address in a city, or the nearest hospital to high-risk road intersections.

To solve this problem, you can calculate the cost matrix with the sites as origins, and the facilities as destinations points. Then, for each row (i.e. each site) you find the column(s) with the lowest cost value. Note that each facility and each site is represented by its nearest node in the network. First blending them into the network using `st_network_blend()` gives the most accurate results.

```{r}
#| warning: false
# Create a network.
net = as_sfnetwork(roxel, directed = FALSE) |>
  st_transform(3035)

# Select a random set of sites and facilities somewhere close to an edge.
pool = st_buffer(st_transform(st_geometry(roxel), 3035), 50)
sites = st_sample(pool, 50)
facilities = st_sample(pool, 5)

# Blend the sites and facilities into the network to get better results.
# Also select only the largest connected component.
new_net = net |>
  convert(to_largest_component, .clean = TRUE) |>
  st_network_blend(c(sites, facilities))

# Calculate the cost matrix.
mat = new_net |>
  st_network_cost(from = sites, to = facilities)

# Find for each site which facility is closest.
closest = facilities[apply(mat, 1, function(x) which(x == min(x))[1])]
```

```{r}
# Create a line between each site and its closest facility, for visualization.
draw_lines = function(sources, targets) {
  f = function(a, b) st_sfc(st_cast(c(a, b), "LINESTRING"))
  lines = do.call("c", mapply(f, sources, targets, SIMPLIFY = FALSE))
  st_crs(lines) = st_crs(sources)
  lines
}

connections = draw_lines(sites, closest)

ggraph(net, "sf") +
  geom_edge_sf(color = "grey") +
  geom_node_sf(color = "grey") +
  geom_sf(data = connections, color = "orange") +
  geom_sf(data = sites, color = "orange", size = 4) +
  geom_sf(data = facilities, color = "skyblue", size = 6) +
  theme_void()
```

### Traveling salesman problem

The traveling salesman problem aims to find the shortest tour that visits every location in a set exactly once. To solve this, `{sfnetworks}` provides an interface to the `TSP::TSP()` function. This requires the `{TSP}` package to be installed. 

The `st_network_travel()` function returns a `sf` object similar to the output of `st_network_paths()`. Each row represent one leg of the route, from one location to the next. Note that each location to visit is represented by its nearest node in the network. First blending them into the network using `st_network_blend()` gives the most accurate results.

```{r}
# We will use the facilities from the previous section as visiting locations.
# They are already blended into the network.
route = st_network_travel(net, facilities)
route
```

```{r}
ggraph(net, "sf") +
  geom_edge_sf(color = "darkgrey") +
  geom_node_sf(color = "darkgrey") +
  geom_sf(data = route, color = "orange", linewidth = 2) +
  geom_sf(data = facilities, size = 6) +
  theme_void()
```

<!-- ### Isochrones and isodistances -->

<!-- With respect to a given point $p$ and a given travel time $t$, an isochrone is the line for which it holds that the travel time from any point on the line to or from $p$ is equal to $t$. When using distances instead of time, it is called an isodistance. -->

<!-- In `sfnetworks` there are no dedicated, optimized functions for calculating isochrones or isodistances. However, we can roughly approximate them by using a combination of sf and tidygraph functions. Lets first calculate imaginary travel times for each edge, using randomly generated average walking speeds for each type of edge. -->

<!-- ```{r} -->
<!-- #| warning: false -->
<!-- # How many edge types are there? -->
<!-- types = net |> -->
<!--   activate("edges") |> -->
<!--   pull(type) |> -->
<!--   unique() -->

<!-- types -->

<!-- # Randomly define a walking speed in m/s for each type. -->
<!-- # With values between 3 and 7 km/hr. -->
<!-- set.seed(1) -->
<!-- speeds = runif(length(types), 3 * 1000 / 60 / 60, 7 * 1000 / 60 / 60) -->

<!-- # Assign a speed to each edge based on its type. -->
<!-- # Calculate travel time for each edge based on that. -->
<!-- net = net |> -->
<!--   activate("edges") |> -->
<!--   group_by(type) |> -->
<!--   mutate(speed = units::set_units(speeds[cur_group_id()], "m/s")) |> -->
<!--   mutate(time = weight / speed) |> -->
<!--   ungroup() -->

<!-- net -->
<!-- ``` -->

<!-- Now, we can calculate the total travel time for each shortest path between the (nearest node of the) origin point and all other nodes in the network, using the node measure function `tidygraph::node_distance_from()` with the values in the *time* column as weights. Then, we filter the nodes reachable within a given travel time from the origin. By drawing a convex hull around these selected nodes we roughly approximate the isochrone. If we wanted isochrones for travel times *towards* the central point, we could have used the node measure function `tidygraph::node_distance_to()` instead. -->

<!-- ```{r} -->
<!-- #| fig-width: 5 -->
<!-- #| fig-height: 5 -->
<!-- net = activate(net, "nodes") -->

<!-- p = net |> -->
<!--   st_geometry() |> -->
<!--   st_combine() |> -->
<!--   st_centroid() -->

<!-- iso = net |> -->
<!--   filter(node_distance_from(st_nearest_feature(p, net), weights = time) <= 600) -->

<!-- iso_poly = iso |> -->
<!--   st_geometry() |> -->
<!--   st_combine() |> -->
<!--   st_convex_hull() -->

<!-- plot(net, col = "grey") -->
<!-- plot(iso_poly, col = NA, border = "black", lwd = 3, add = TRUE) -->
<!-- plot(iso, col = colors[2], add = TRUE) -->
<!-- plot(p, col = colors[1], pch = 8, cex = 2, lwd = 2, add = TRUE) -->
<!-- ``` -->

<!-- The workflow presented above is generalized in a spatial morpher function `to_spatial_neighborhood()`, which can be used inside the `tidygraph::convert()` verb to filter only those nodes that can be reached within a given travel cost from the given origin node. -->

<!-- ```{r} -->
<!-- #| fig-width: 5 -->
<!-- #| fig-height: 5 -->
<!-- # Define the threshold values (in seconds). -->
<!-- # Define also the colors to plot the neighborhoods in. -->
<!-- thresholds = rev(seq(60, 600, 60)) -->
<!-- palette = sf.colors(n = 10) -->

<!-- # Plot the results. -->
<!-- plot(net, col = "grey") -->

<!-- for (i in c(1:10)) { -->
<!--   nbh = convert(net, to_spatial_neighborhood, p, thresholds[i], weights = "time") -->
<!--   plot(nbh, col = palette[i], add = TRUE) -->
<!-- } -->

<!-- plot(p, pch = 8, cex = 2, lwd = 2, add = TRUE) -->
<!-- ``` -->

<!-- ### Custom routing -->

<!-- In many cases the shortest path based geographical distances or travel time is not necessarily the optimal path. The most appropriate route may depend on many factors, for example staying away from large and potentially unpleasant highways for motor traffic. All networks have different characteristics. In OpenStreetMap networks the 'highway' type is often a good (albeit crude) approximation of the network. The `roxel` demo dataset is derived from OpenStreetMap and represents a largely residential network: -->

<!-- ```{r} -->
<!-- table(roxel$type) -->
<!-- ``` -->

<!-- Building on the shortest paths calculated in a previous section we can try an alternative routing profile. Let's take a look at these paths to see what type of ways they travel on: -->

<!-- ```{r} -->
<!-- paths_sf = net |> -->
<!--   activate("edges") |> -->
<!--   slice(unlist(paths$edges)) |> -->
<!--   st_as_sf() -->

<!-- table(paths_sf$type) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| fig-width: 5 -->
<!-- #| fig-height: 5 -->
<!-- plot(paths_sf["type"], lwd = 4, key.pos = 4, key.width = lcm(4)) -->
<!-- ``` -->

<!-- As with the overall network, the paths we calculated are dominated by residential streets. -->
<!-- For the purposes of illustration, lets imagine we're routing for a vehicle that we want to keep away from residential roads, and which has a much lower cost per unit distance on secondary roads: -->

<!-- ```{r} -->
<!-- weighting_profile = c( -->
<!--   cycleway = Inf, -->
<!--   footway = Inf, -->
<!--   path = Inf, -->
<!--   pedestrian = Inf, -->
<!--   residential = 3, -->
<!--   secondary = 1, -->
<!--   service = 1, -->
<!--   track = 10, -->
<!--   unclassified = 1 -->
<!-- ) -->

<!-- weighted_net = net |> -->
<!--   activate("edges") |> -->
<!--   mutate(multiplier = ifelse(is.na(type), 1, weighting_profile[type])) |> -->
<!--   mutate(weight = edge_length() * multiplier) -->
<!-- ``` -->

<!-- We can now recalculate the routes. The result show routes that avoid residential networks. -->

<!-- ```{r} -->
<!-- weighted_paths = st_network_paths(weighted_net, from = 495, to = c(458, 121), weights = "weight") -->

<!-- weighted_paths_sf = weighted_net |> -->
<!--   activate("edges") |> -->
<!--   slice(unlist(weighted_paths$edges)) |> -->
<!--   st_as_sf() -->

<!-- table(weighted_paths_sf$type) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| layout-ncol: 2 -->
<!-- #| fig-cap: -->
<!-- #|   - "Distance weights" -->
<!-- #|   - "Custom weights" -->
<!-- plot(st_as_sf(net, "edges")["type"], lwd = 4, -->
<!--      key.pos = NULL, reset = FALSE) -->
<!-- plot(st_geometry(paths_sf), add = TRUE) -->
<!-- plot(st_as_sf(net, "edges")["type"], lwd = 4, -->
<!--      key.pos = NULL, reset = FALSE) -->
<!-- plot(st_geometry(weighted_paths_sf), add = TRUE) -->
<!-- ``` -->

<!-- Note that developing more sophisticated routing profiles is beyond the scope of this package. -->
<!-- If you need complex mode-specific routing profiles, we recommend looking at routing profiles associated with open source routing engines, such as [bike.lua](https://github.com/fossgis-routing-server/cbf-routing-profiles/blob/master/bike.lua) in the OSRM project. Another direction of travel could be to extend on the approach illustrated here, but this work could be well-suited to a separate package that builds on `sfnetworks` (remembering that sophisticated routing profiles account for nodes and edges). If you'd like to work on such a project to improve mode-specific routing in R by building on this package, please let us know in the [discussion room](https://github.com/luukvdmeer/sfnetworks/discussions)! -->

```{r}
#| include: false
par(oldpar)
options(oldoptions)
```
